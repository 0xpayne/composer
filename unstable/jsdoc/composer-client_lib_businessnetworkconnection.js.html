{#
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
#}
<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Hyperledger Composer Source: composer-client/lib/businessnetworkconnection.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.spacelab.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Hyperledger Composer</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-composer-admin.html">composer-admin</a></li><li><a href="module-composer-client.html">composer-client</a></li><li><a href="module-composer-common.html">composer-common</a></li><li><a href="module-composer-runtime.html">composer-runtime</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Certificate.html">Certificate</a></li><li><a href="CertificateUtil.html">CertificateUtil</a></li><li><a href="module-composer-admin.AdminConnection.html">composer-admin.AdminConnection</a></li><li><a href="module-composer-client.AssetRegistry.html">composer-client.AssetRegistry</a></li><li><a href="module-composer-client.BusinessNetworkConnection.html">composer-client.BusinessNetworkConnection</a></li><li><a href="module-composer-client.Historian.html">composer-client.Historian</a></li><li><a href="module-composer-client.IdentityRegistry.html">composer-client.IdentityRegistry</a></li><li><a href="module-composer-client.ParticipantRegistry.html">composer-client.ParticipantRegistry</a></li><li><a href="module-composer-client.Query.html">composer-client.Query</a></li><li><a href="module-composer-client.Registry.html">composer-client.Registry</a></li><li><a href="module-composer-client.TransactionRegistry.html">composer-client.TransactionRegistry</a></li><li><a href="module-composer-common.AssetDeclaration.html">composer-common.AssetDeclaration</a></li><li><a href="module-composer-common.BusinessNetworkCardStore.html">composer-common.BusinessNetworkCardStore</a></li><li><a href="module-composer-common.BusinessNetworkDefinition.html">composer-common.BusinessNetworkDefinition</a></li><li><a href="module-composer-common.BusinessNetworkMetadata.html">composer-common.BusinessNetworkMetadata</a></li><li><a href="module-composer-common.ClassDeclaration.html">composer-common.ClassDeclaration</a></li><li><a href="module-composer-common.Concept.html">composer-common.Concept</a></li><li><a href="module-composer-common.ConceptDeclaration.html">composer-common.ConceptDeclaration</a></li><li><a href="module-composer-common.EnumDeclaration.html">composer-common.EnumDeclaration</a></li><li><a href="module-composer-common.EnumValueDeclaration.html">composer-common.EnumValueDeclaration</a></li><li><a href="module-composer-common.EventDeclaration.html">composer-common.EventDeclaration</a></li><li><a href="module-composer-common.Factory.html">composer-common.Factory</a></li><li><a href="module-composer-common.FunctionDeclaration.html">composer-common.FunctionDeclaration</a></li><li><a href="module-composer-common.IdCard.html">composer-common.IdCard</a></li><li><a href="module-composer-common.Identifiable.html">composer-common.Identifiable</a></li><li><a href="module-composer-common.Introspector.html">composer-common.Introspector</a></li><li><a href="module-composer-common.ModelFile.html">composer-common.ModelFile</a></li><li><a href="module-composer-common.ModelManager.html">composer-common.ModelManager</a></li><li><a href="module-composer-common.ParticipantDeclaration.html">composer-common.ParticipantDeclaration</a></li><li><a href="module-composer-common.Property.html">composer-common.Property</a></li><li><a href="module-composer-common.Relationship.html">composer-common.Relationship</a></li><li><a href="module-composer-common.RelationshipDeclaration.html">composer-common.RelationshipDeclaration</a></li><li><a href="module-composer-common.Resource.html">composer-common.Resource</a></li><li><a href="module-composer-common.Serializer.html">composer-common.Serializer</a></li><li><a href="module-composer-common.TransactionDeclaration.html">composer-common.TransactionDeclaration</a></li><li><a href="module-composer-common.Typed.html">composer-common.Typed</a></li><li><a href="module-composer-common.ValidatedConcept.html">composer-common.ValidatedConcept</a></li><li><a href="module-composer-common.ValidatedResource.html">composer-common.ValidatedResource</a></li><li><a href="module-composer-runtime.Api.html">composer-runtime.Api</a></li><li><a href="module-composer-runtime.AssetRegistry.html">composer-runtime.AssetRegistry</a></li><li><a href="module-composer-runtime.Factory.html">composer-runtime.Factory</a></li><li><a href="module-composer-runtime.ParticipantRegistry.html">composer-runtime.ParticipantRegistry</a></li><li><a href="module-composer-runtime.Query.html">composer-runtime.Query</a></li><li><a href="module-composer-runtime.Serializer.html">composer-runtime.Serializer</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#getLogger">getLogger</a></li><li><a href="global.html#PREFIX">PREFIX</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			{#
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
#}


		<h1 class="page-title">Source: composer-client/lib/businessnetworkconnection.js</h1>
    {#
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
#}

<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const AssetRegistry = require('./assetregistry');
const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition;
const ConnectionProfileManager = require('composer-common').ConnectionProfileManager;
const EventEmitter = require('events');
const Historian = require('./historian');
const IdentityRegistry = require('./identityregistry');
const Logger = require('composer-common').Logger;
const ParticipantRegistry = require('./participantregistry');
const Query = require('./query');
const Relationship = require('composer-common').Relationship;
const Resource = require('composer-common').Resource;
const TransactionDeclaration = require('composer-common').TransactionDeclaration;
const TransactionRegistry = require('./transactionregistry');
const Util = require('composer-common').Util;
const uuid = require('uuid');
const Registry = require('./registry');
const NetworkCardStoreManager = require('composer-common').NetworkCardStoreManager;
const LOG = Logger.getLog('BusinessNetworkConnection');

/**
 * Use this class to connect to and then interact with a deployed
 * {@link module:composer-common.BusinessNetworkDefinition Business Network Definition}.
 * Use the AdminConnection class in the composer-admin module to deploy
 * BusinessNetworksDefinitions.
 * @extends EventEmitter
 * @class
 * @memberof module:composer-client
 */
class BusinessNetworkConnection extends EventEmitter {

    /**
     * Creates an instance of the BusinessNetworkConnection class.
     * Must be called to connect to a deployed BusinessNetworkDefinition.
     * @param {Object} [options] - an optional set of options to configure the
     * instance.
     * @param {BusinessNetworkCardStore} [options.cardStore] specify a card
     * store implementation to use.
     */
    constructor(options) {
        super();
        const method = 'constructor';
        LOG.entry(method, options);
        options = options || {};

        this.cardStore = options.cardStore || NetworkCardStoreManager.getCardStore(options.wallet);
        this.connectionProfileManager = new ConnectionProfileManager();
        this.connection = null;
        this.securityContext = null;
        this.businessNetwork = null;
        this.dynamicQueryFile = null;
        this.card = null;
    }

    /**
     * Gets the currently connected business network.
     * {@link module:composer-common.BusinessNetworkDefinition Business Network Definition}.
     * @example
     * const connection = new BusinessNetworkConnection();
     * const definition = await connection.connect('admin@network-name');
     * console.log(definition === connection.getBusinessNetwork());  // true
     * @returns {BusinessNetworkDefinition} the business network definition
     */
    getBusinessNetwork() {
        return this.businessNetwork;
    }


    /**
     * Gets a list of all existing asset registries.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const assetRegistries = await connection.getAllAssetRegistries();
     * @param {boolean} [includeSystem] if true the returned list will include
     * the system transaction registries (optional, default to false)
     * @returns {Promise} - A promise that will be resolved with a list of
     * existing {@link AssetRegistry asset registries}.
     */
    getAllAssetRegistries(includeSystem) {
        Util.securityCheck(this.securityContext);
        let sysReg = includeSystem || false;
        return AssetRegistry.getAllAssetRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this, sysReg);
    }

    /**
     * Gets an existing asset registry.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const sampleAssetRegistry = await connection.getAssetRegistry('org.example.SampleAsset');
     * @param {string} id - The unique identifier of the asset registry
     * @returns {Promise} - A promise that will be resolved with the existing
     * {@link AssetRegistry}, or rejected if it does not exist.
     */
    getAssetRegistry(id) {
        Util.securityCheck(this.securityContext);
        return AssetRegistry.getAssetRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }

    /**
     * Determines whether an asset registry exists.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const exists = await connection.assetRegistryExists('org.example.SampleAsset');
     * if (exists) {
     *     // logic here...
     * }
     * @param {string} id - The unique identifier of the asset registry
     * @returns {Promise} - A promise that will be resolved with a boolean
     * indicating whether the {@link AssetRegistry} exists.
     */
    assetRegistryExists(id) {
        Util.securityCheck(this.securityContext);
        return AssetRegistry.assetRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }

    /**
     * Adds a new asset registry.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * await connection.addAssetRegistry('registryId', 'registryName');
     * @param {string} id - The unique identifier of the asset registry
     * @param {string} name - The name of the asset registry
     * @returns {Promise} - A promise that will be resolved with the new
     * {@link AssetRegistry} after it has been added.
     */
    addAssetRegistry(id, name) {
        Util.securityCheck(this.securityContext);
        return AssetRegistry.addAssetRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }


    /**
     * Gets a list of all existing participant registries.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const participantRegistries = await connection.getAllParticipantRegistries();
     * @param {boolean} [includeSystem] if true the returned list will include
     * the system transaction registries (optional, default to false)
     * @returns {Promise} - A promise that will be resolved with a list of
     * existing {@link ParticipantRegistry participant registries}.
     */
    getAllParticipantRegistries(includeSystem) {
        Util.securityCheck(this.securityContext);
        let sysReg = includeSystem || false;
        return ParticipantRegistry.getAllParticipantRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this, sysReg);
    }

    /**
     * Gets an existing participant registry.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const sampleParticipantRegistry = await connection.getParticipantRegistry('org.example.SampleParticipant');
     * @param {string} id - The unique identifier of the participant registry
     * @returns {Promise} - A promise that will be resolved with the existing
     * {@link ParticipantRegistry}, or rejected if it does not exist.
     */
    getParticipantRegistry(id) {
        Util.securityCheck(this.securityContext);
        return ParticipantRegistry.getParticipantRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }

    /**
     * Determines whether a participant registry exists.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const exists = await connection.participantRegistryExists('org.example.SampleParticipant');
     * if (exists) {
     *     // logic here...
     * }
     * @param {string} id - The unique identifier of the participant registry
     * @returns {Promise} - A promise that will be resolved with a boolean
     * indicating whether the {@link ParticipantRegistry} exists.
     */
    participantRegistryExists(id) {
        Util.securityCheck(this.securityContext);
        return ParticipantRegistry.participantRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }

    /**
     * Adds a new participant registry.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * await connection.addParticipantRegistry('registryId', 'registryName');
     * @param {string} id - The unique identifier of the participant registry
     * @param {string} name - The name of the participant registry
     * @returns {Promise} - A promise that will be resolved with the new
     * {@link ParticipantRegistry} after it has been added.
     */
    addParticipantRegistry(id, name) {
        Util.securityCheck(this.securityContext);
        return ParticipantRegistry.addParticipantRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }


    /**
     * Gets an existing transaction registry.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const sampleTransactionRegistry = await connection.getTransactionRegistry('org.example.SampleTransaction');
     * @param {string} id - The unique identifier of the transaction registry
     * @returns {Promise} - A promise that will be resolved with the existing
     * {@link TransactionRegistry}, or rejected if it does not exist.
     */
    getTransactionRegistry(id) {
        Util.securityCheck(this.securityContext);
        return TransactionRegistry.getTransactionRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }

    /**
     * Gets a list of all existing transaction registries.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const transactionRegistries = await connection.getAllTransactionRegistries();
     * @param {boolean} [includeSystem] if true the returned list will include
     * the system transaction registries (optional, default to false)
     * @returns {Promise} - A promise that will be resolved with a list of
     * existing {@link TransactionRegistry transaction registries}.
     */
    getAllTransactionRegistries(includeSystem) {
        Util.securityCheck(this.securityContext);
        let sysReg = includeSystem || false;
        return TransactionRegistry.getAllTransactionRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this, sysReg);
    }

    /**
     * Determines whether a transaction registry exists.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const exists = await connection.transactionRegistryExists('org.example.SampleTransaction');
     * if (exists) {
     *     // logic here...
     * }
     * @param {string} id - The unique identifier of the transaction registry
     * @returns {Promise} - A promise that will be resolved with a boolean
     * indicating whether the {@link TransactionRegistry} exists.
     */
    transactionRegistryExists(id) {
        Util.securityCheck(this.securityContext);
        return TransactionRegistry.transactionRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer(), this);
    }


    /**
     * Gets the historian.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const historian = await connection.getHistorian();
     * @returns {Promise} - A promise that will be resolved with the
     * {@link Historian}.
     */
    getHistorian() {
        Util.securityCheck(this.securityContext);
        return Historian
            .getHistorian(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer())
            .then((historian) => {
                if (historian) {
                    return historian;
                } else {
                    throw new Error('Failed to find the historian');
                }
            });
    }


    /**
     * Gets the identity registry.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const identityRegistry = await connection.getIdentityRegistry();
     * @returns {Promise} - A promise that will be resolved with the
     * {@link IdentityRegistry}.
     */
    getIdentityRegistry() {
        Util.securityCheck(this.securityContext);
        return IdentityRegistry
            .getIdentityRegistry(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer())
            .then((identityRegistry) => {
                if (identityRegistry) {
                    return identityRegistry;
                } else {
                    throw new Error('Failed to find the identity registry');
                }
            });
    }


    /**
     * Connects to a business network using a business network card, and
     * authenticates to the Hyperledger Fabric.
     * @example
     * const connection = new BusinessNetworkConnection();
     * const definition = await connection.connect('admin@network-name');
     * @param {String} cardName  businessNetworkCard Name (must have been
     * imported already)
     * @param {Object} [additionalConnectOptions] Additional configuration
     * options supplied at runtime that override options set in the connection
     * profile, which will override those in the specified connection profile.
     * @returns {Promise} A promise that will be resolved with a
     * {@link module:composer-common.BusinessNetworkDefinition BusinessNetworkDefinition}
     * that indicates the connection is completed.
     */
    async connect(cardName, additionalConnectOptions) {
        const method = 'connect';
        LOG.entry(method, cardName, additionalConnectOptions);

        this.card = await this.cardStore.get(cardName);
        if (!additionalConnectOptions) {
            additionalConnectOptions = {};
        }

        // need to get from the cardstore, a wallet that uses the same backing store
        const wallet = await this.cardStore.getWallet(cardName);
        additionalConnectOptions.wallet = wallet;
        additionalConnectOptions.cardName = cardName;
        const connection = await this.connectionProfileManager.connectWithData(this.card.getConnectionProfile(), this.card.getBusinessNetworkName(), additionalConnectOptions);

        let secret = this.card.getEnrollmentCredentials();
        if (!secret) {
            secret = 'na';
        } else {
            secret = secret.secret;
        }

        const businessNetworkDefinition = await this._connectionLogin(connection, this.card.getUserName(), secret);
        LOG.exit(method, businessNetworkDefinition);
        return businessNetworkDefinition;
    }

    /**
     * Get the business network card used by this connection, if a business
     * network card was used.
     * @returns {IdCard} The business network card (an instance of
     * {@link module:composer-common.IdCard IdCard}) used by this connection,
     * or null if a business network card was not used.
     * @private
     */
    getCard() {
        return this.card;
    }

    /**
     * Internal method to login and process the connection.
     * @private
     * @param {Connection} connection connection just established (an instance
     * of {@link module:composer-common.Connection Connection})
     * @param {string} enrollId enrollment id
     * @param {string} enrollmentSecret enrollment secret
     * @returns {Promise} A promise that will be resolved with a
     * {@link module:composer-common.BusinessNetworkDefinition BusinessNetworkDefinition}
     * when completed.
     */
    _connectionLogin(connection, enrollId, enrollmentSecret) {
        const method = '_connectionLogin';
        LOG.entry(method);

        return Promise.resolve()
            .then(() => {
                connection.on('events', (events) => {
                    events.forEach((event) => {
                        let serializedEvent = this.getBusinessNetwork().getSerializer().fromJSON(event);
                        this.emit('event', serializedEvent);
                    });
                });
                this.connection = connection;
                return connection.login(enrollId, enrollmentSecret);
            })
            .then((securityContext) => {
                this.securityContext = securityContext;
                return this.ping();
            })
            .then(() => {
                return Util.queryChainCode(this.securityContext, 'getBusinessNetwork', []);
            })
            .then((buffer) => {
                let businessNetworkJSON = JSON.parse(buffer.toString());
                let businessNetworkArchive = Buffer.from(businessNetworkJSON.data, 'base64');
                return BusinessNetworkDefinition.fromArchive(businessNetworkArchive);
            })
            .then((businessNetwork) => {
                this.businessNetwork = businessNetwork;
                this.dynamicQueryFile = this.businessNetwork.getQueryManager().createQueryFile('$dynamic_queries.qry', '');
                LOG.exit(method);
                return this.businessNetwork;
            });
    }

    /**
     * Given a fully qualified name, works out and looks up the registry that
     * this resource will be found in.
     * This only gives back the default registry - it does not look in any
     * application defined registry.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const sampleAssetRegistry = await connection.getRegistry('org.example.SampleAsset');
     * const sampleParticipantRegistry = await connection.getRegistry('org.example.SampleParticipant');
     * const sampleTransactionRegistry = await connection.getRegistry('org.example.SampleTransaction');
     * @param {String} fullyQualifiedName The fully qualified name of the
     * resource registry
     * @returns {Promise} A promise that will be resolved with the registry that
     * this fully qualified name could be found in by default.
     */
    getRegistry(fullyQualifiedName) {
        Util.securityCheck(this.securityContext);
        let businessNetwork = this.getBusinessNetwork();
        let type = businessNetwork.getModelManager().getType(fullyQualifiedName).getSystemType();
        return Registry.getRegistry(this.securityContext, type, fullyQualifiedName)
            .then((registry) => {
                switch (type) {
                case 'Transaction':
                    return new TransactionRegistry(registry.id,
                        registry.name,
                        this.securityContext,
                        businessNetwork.getModelManager(),
                        businessNetwork.getFactory(),
                        businessNetwork.getSerializer(),
                        this);
                case 'Asset':
                    return new AssetRegistry(registry.id,
                        registry.name,
                        this.securityContext,
                        businessNetwork.getModelManager(),
                        businessNetwork.getFactory(),
                        businessNetwork.getSerializer(),
                        this);
                case 'Participant':
                    return new ParticipantRegistry(registry.id,
                        registry.name,
                        this.securityContext,
                        businessNetwork.getModelManager(),
                        businessNetwork.getFactory(),
                        businessNetwork.getSerializer(),
                        this);
                }
            });

    }

    /**
     * Disconnects from the Hyperledger Fabric.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * // Connected.
     * await connection.disconnect();
     * // Disconnected.
     * @returns {Promise} A promise that will be resolved when the connection is
     * terminated.
     */
    disconnect() {
        const method = 'disconnect';
        LOG.entry(method);
        if (!this.connection) {
            return Promise.resolve();
        }
        return this.connection.disconnect()
            .then(() => {
                this.connection.removeListener('events', () => {
                    LOG.debug(method, 'removeListener');
                });
                this.connection = null;
                this.securityContext = null;
                this.businessNetwork = null;
                this.dynamicQueryFile = null;
                this.card = null;
                LOG.exit(method);
            });
    }

    /**
     * Submit a transaction for processing by the currently connected business
     * network.
     * @example
     * const connection = new BusinessNetworkConnection();
     * const definition = await connection.connect('admin@network-name');
     * const factory = definition.getFactory();
     * const transaction = factory.newTransaction('org.example', 'SampleTransaction');
     * await connection.submitTransaction(transaction);
     * @param {Resource} transaction - The transaction to submit. Use
     * {@link module:composer-common.Factory#newTransaction newTransaction} to
     * create this object.
     * @returns {Promise} A promise that will be fulfilled when the transaction
     * has been processed.
     */
    submitTransaction(transaction) {
        Util.securityCheck(this.securityContext);
        if (!transaction) {
            throw new Error('transaction not specified');
        }
        let classDeclaration = transaction.getClassDeclaration();
        if (!(classDeclaration instanceof TransactionDeclaration)) {
            throw new Error(classDeclaration.getFullyQualifiedName() + ' is not a transaction');
        }

        return Util.createTransactionId(this.securityContext)
            .then((id) => {
                transaction.setIdentifier(id.idStr);
                transaction.timestamp = new Date();
                let data = this.getBusinessNetwork().getSerializer().toJSON(transaction);
                return Util.invokeChainCode(this.securityContext, 'submitTransaction', [JSON.stringify(data)], { transactionId: id.id });
            });

    }

    /**
     * Build a query ready for later execution. The specified query string must
     * be written in the Composer Query Language.
     *
     * This functionality is Blockchain platform dependent. For example, when a
     * Composer business network is deployed to Hyperledger Fabric v1.0,
     * Hyperledger Fabric must be configured with the CouchDB database for the
     * world state.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const query = connection.buildQuery('SELECT org.example.SampleAsset WHERE (value == _$inputValue)');
     * const assets = await connection.query(query, { inputValue: 'blue' })
     * @param {string} query The query string, written in the Composer Query
     * Language.
     * @returns {Query} The built query, which can be passed in a call to query.
     */
    buildQuery(query) {
        const method = 'buildQuery';
        LOG.entry(method, query);
        const builtQuery = this.dynamicQueryFile.buildQuery('Dynamic query', 'Dynamic query', query);
        builtQuery.validate();
        const result = new Query(query);
        LOG.exit(method, result);
        return result;
    }

    /**
     * Execute a query defined in a Composer query file, or execute a query
     * built with buildQuery.
     *
     * This functionality is Blockchain platform dependent. For example, when a
     * Composer business network is deployed to Hyperledger Fabric v1.0,
     * Hyperledger Fabric must be configured with the CouchDB database for the
     * world state.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * const assets = await query('Q1', { inputValue: 'blue' })
     * @param {string|Query} query The name of the query, or a built query.
     * @param {Object} [parameters] The parameters for the query.
     * @returns {Promise} A promise that will be resolved with an array of
     * {@link module:composer-common.Resource Resource} representing the
     * resources returned by the query.
     */
    query(query, parameters) {
        const method = 'query';
        LOG.entry(method, query, parameters);
        let queryType, identifier;
        if (query instanceof Query) {
            queryType = 'build';
            identifier = query.getIdentifier();
        } else if (typeof query === 'string') {
            queryType = 'named';
            identifier = query;
        } else {
            throw new Error('Invalid query; expecting a built query or the name of a query');
        }
        parameters = parameters || {};
        return Util.queryChainCode(this.securityContext, 'executeQuery', [queryType, identifier, JSON.stringify(parameters)])
            .then((buffer) => {
                return JSON.parse(buffer.toString());
            })
            .then((resources) => {
                const result = resources.map((resource) => {
                    return this.getBusinessNetwork().getSerializer().fromJSON(resource);
                });
                LOG.exit(method, result);
                return result;
            });
    }

    /**
     * Test the connection to the runtime and verify that the version of the
     * runtime is compatible with this level of the client node.js module.
     * @example
     * const connection = new BusinessNetworkConnection();
     * await connection.connect('admin@network-name');
     * await connection.ping();
     * @returns {Promise} A promise that will be fulfilled when the connection
     * has been tested. The promise will be rejected if the version is
     * incompatible.
     */
    ping() {
        const method = 'ping';
        LOG.entry(method);
        return this.pingInner()
            .catch((error) => {
                if (error.message.match(/ACTIVATION_REQUIRED/)) {
                    LOG.debug(method, 'Activation required, activating ...');
                    return this.activate()
                        .then(() => {
                            return this.pingInner();
                        });
                }
                throw error;
            })
            .then((result) => {
                LOG.exit(method, result);
                return result;
            });
    }

    /**
     * Test the connection to the runtime and verify that the version of the
     * runtime is compatible with this level of the client node.js module.
     * @private
     * @returns {Promise} A promise that will be fulfilled when the connection
     * has been tested. The promise will be rejected if the version is
     * incompatible.
     */
    pingInner() {
        const method = 'pingInner';
        LOG.entry(method);
        Util.securityCheck(this.securityContext);
        return this.connection.ping(this.securityContext)
            .then((result) => {
                LOG.exit(method, result);
                return result;
            });
    }

    /**
     * Activate the current identity on the currently connected business
     * network.
     * @private
     * @returns {Promise} A promise that will be fulfilled when the connection
     * has been tested. The promise will be rejected if the version is
     * incompatible.
     */
    activate() {
        const method = 'activate';
        LOG.entry(method);
        const json = {
            $class: 'org.hyperledger.composer.system.ActivateCurrentIdentity',
            transactionId: uuid.v4(),
            timestamp: new Date().toISOString()
        };
        return Util.invokeChainCode(this.securityContext, 'submitTransaction', [JSON.stringify(json)])
            .then(() => {
                LOG.exit(method);
            });
    }

    /**
     * Issue an identity with the specified name and map it to the specified
     * participant.
     * @param {Resource|Relationship|string} participant The participant, a
     * relationship to the participant, or the fully qualified identifier of
     * the participant. The participant must already exist.
     * @param {string} identityName The name for the new identity.
     * @param {object} [options] Options for the new identity.
     * @param {boolean} [options.issuer] Whether or not the new identity should
     * have permissions to create additional new identities. False by default.
     * @returns {Promise} A promise that will be fulfilled when the identity has
     * been added to the specified participant. The promise will be rejected if
     * the participant does not exist, or if the identity is already mapped to
     * another participant.
     */
    issueIdentity(participant, identityName, options) {
        const method = 'issueIdentity';
        LOG.entry(method, participant, identityName);
        if (!participant) {
            throw new Error('participant not specified');
        } else if (!identityName) {
            throw new Error('identityName not specified');
        }
        const factory = this.getBusinessNetwork().getFactory();
        if (participant instanceof Resource) {
            participant = factory.newRelationship(participant.getNamespace(), participant.getType(), participant.getIdentifier());
        } else if (participant instanceof Relationship) {
            // This is OK!
        } else {
            participant = Relationship.fromURI(this.getBusinessNetwork().getModelManager(), participant);
        }
        const transaction = factory.newTransaction('org.hyperledger.composer.system', 'IssueIdentity');
        Object.assign(transaction, {
            participant,
            identityName
        });
        return this.getParticipantRegistry(participant.getFullyQualifiedType())
            .then((participantRegistry) => {
                return participantRegistry.exists(participant.getIdentifier());
            })
            .then((exists) => {
                if (exists) {
                    if (this.connection.registryCheckRequired()) {
                        return this.getIdentityRegistry()
                            .then((registry) => {
                                return registry.getAll();
                            })
                            .then((ids) => {
                                ids = ids.map((el) => {
                                    return el.name;
                                });

                                if (ids.includes(identityName)) {
                                    throw new Error(`Identity with name ${identityName} already exists in ${this.getBusinessNetwork().getName()}`);
                                }
                            });
                    }
                } else {
                    throw new Error(`Participant '${participant.getFullyQualifiedIdentifier()}' does not exist `);
                }
            })
            .then(() => {
                return this.connection.createIdentity(this.securityContext, identityName, options);
            })
            .then((identity) => {
                return this.submitTransaction(transaction)
                    .then(() => {
                        LOG.exit(method, identity);
                        return identity;
                    });
            });
    }

    /**
     * Bind an existing identity to the specified participant.
     * @param {Resource|string} participant The participant, or the fully
     * qualified identifier of the participant. The participant must already
     * exist.
     * @param {string} certificate The certificate for the existing identity.
     * @returns {Promise} A promise that will be fulfilled when the identity has
     * been added to the specified participant. The promise will be rejected if
     * the participant does not exist, or if the identity is already mapped to
     * another participant.
     */
    bindIdentity(participant, certificate) {
        const method = 'bindIdentity';
        LOG.entry(method, participant, certificate);
        if (!participant) {
            throw new Error('participant not specified');
        } else if (!certificate) {
            throw new Error('certificate not specified');
        }
        const factory = this.getBusinessNetwork().getFactory();
        if (participant instanceof Resource) {
            participant = factory.newRelationship(participant.getNamespace(), participant.getType(), participant.getIdentifier());
        } else if (participant instanceof Relationship) {
            // This is OK!
        } else {
            participant = Relationship.fromURI(this.getBusinessNetwork().getModelManager(), participant);
        }
        const transaction = factory.newTransaction('org.hyperledger.composer.system', 'BindIdentity');
        Object.assign(transaction, {
            participant,
            certificate
        });
        return this.submitTransaction(transaction)
            .then(() => {
                LOG.exit(method);
            });
    }

    /**
     * Revoke the specified identity by removing any existing mapping to a
     * participant.
     * @param {Resource|string} identity The identity, or the identifier of the
     * identity.
     * @returns {Promise} A promise that will be fulfilled when the identity has
     * been removed from the specified participant. The promise will be rejected
     * if the participant does not exist, or if the identity is not mapped to
     * the participant.
     */
    revokeIdentity(identity) {
        const method = 'revokeIdentity';
        LOG.entry(method, identity);
        if (!identity) {
            throw new Error('identity not specified');
        }
        const factory = this.getBusinessNetwork().getFactory();
        if (identity instanceof Resource) {
            identity = factory.newRelationship(identity.getNamespace(), identity.getType(), identity.getIdentifier());
        } else if (identity instanceof Relationship) {
            // This is OK!
        } else {
            identity = Relationship.fromURI(this.getBusinessNetwork().getModelManager(), identity, 'org.hyperledger.composer.system', 'Identity');
        }
        const transaction = factory.newTransaction('org.hyperledger.composer.system', 'RevokeIdentity');
        Object.assign(transaction, {
            identity
        });
        // It is not currently possible to revoke the certificate, so we just
        // call the runtime to remove the mapping.
        return this.submitTransaction(transaction)
            .then(() => {
                LOG.exit(method);
            });
    }

}

module.exports = BusinessNetworkConnection;
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>

	 


	<span class="copyright">
	2017 Copyright IBM Corp. All Rights Reserved
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
	
		on Sat Apr 14th 2018
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
